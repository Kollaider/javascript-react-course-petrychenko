"use strict";

// Массивы — частные случаи объектов
const arr = ['a', 'b', 'c'];

const arrObj = {
    0: 'a',
    1: 'b',
    2: 'c'
};

// Обычный объект с символьными ключами
const obj = {
    a: 1,
    b: 2,
    c: 3
};

console.log(arr[1]); // 'b'

// Объект с ключами-строками
const obj2 = {
    Anna: 200,
    'Alice': 800
};

// Свойства объекта можно записывать как без кавычек (если имя — допустимый идентификатор), так и в кавычках

// Сравнение доступа к массиву и объекту с числовыми ключами
console.log(arr[1]);    // 'b' — доступ к элементу массива
console.log(arrObj[1]); // 'b' — доступ к значению по числовому ключу объекта

// Изменение объектов и добавление новых свойств

// 1-й способ: через точку
arrObj.b = '1234';
console.log(arrObj['b']); // '1234'
console.log(arrObj.b);    // '1234'

// 2-й способ: через квадратные скобки (ключ — строка)
arrObj['c'] = 1234;
console.log(arrObj.c); // 1234

console.log(arrObj);
// Вывод:
// { '0': 'a', '1': 'b', '2': 'c', b: '1234', c: 1234 }

// Расширение массива за пределы текущей длины
const arr3 = ['a', 'b', 'c'];
arr3[10] = 'ddd';

console.log(arr3);       // [ 'a', 'b', 'c', <7 empty items>, 'ddd' ]
console.log(arr3[10]);   // 'ddd'
console.log(arr3[5]);    // undefined — такого элемента нет, но ячейка зарезервирована
console.log(arr3[100]);  // undefined — за пределами массива

// Вложенные структуры в объектах
const obj3 = {
    Anna: 200,
    'Alice': 800,
    abc: {
        df: [{}, {}],    // массив из двух пустых объектов
        def: {
            // вложенный объект, пока пустой
        }
    }
};
