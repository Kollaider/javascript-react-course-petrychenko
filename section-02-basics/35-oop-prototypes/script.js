"use strict";

// Разница между примитивом string и объектом String
let str = "some";
let strObj = new String(str); // Создание объектной обертки для примитива

console.log(typeof str);    // "string" - примитивный тип
console.log(typeof strObj); // "object" - объект String

// Демонстрация структуры массива
console.dir([1, 2, 3]);

// Базовый объект-прототип
const soldier = {
    health: 400,
    armor: 100,
    sayHello: function() {
        console.log('Hello');
    }
};

// Объект, который будет наследовать свойства
const john = {
    health: 100
};

// 1. УСТАРЕВШИЙ способ установки прототипа (не рекомендуется)
john.__proto__ = soldier;
console.log(john.armor); // 100 (наследуется от soldier)
john.sayHello();         // "Hello" (наследуется от soldier)

// 2. СОВРЕМЕННЫЙ способ установки прототипа
Object.setPrototypeOf(john, soldier); // Аналог __proto__, но стандартизирован

// 3. Создание объекта с указанным прототипом (лучшая практика)
const peter = Object.create(soldier); // Создает новый объект с прототипом soldier
peter.sayHello(); // "Hello" (метод наследуется)

/*
Основные концепции:
1. Разница между примитивами и объектами-обертками:
   - str - примитив типа string
   - strObj - объект String, обертка вокруг примитива

2. Прототипное наследование:
   - __proto__ - устаревший способ (не используйте в production)
   - Object.setPrototypeOf() - современная замена __proto__
   - Object.create() - лучший способ создания объектов с нужным прототипом

3. Принцип работы:
   - Если свойство не найдено в объекте, JS ищет его в прототипе
   - Цепочка прототипов может быть длинной
   - Методы в прототипе доступны всем наследующим объектам

Рекомендации:
- Используйте Object.create() для создания объектов с прототипами
- Избегайте __proto__ и Object.setPrototypeOf() после создания объекта
- Для классов используйте синтаксис class (ES6+)
*/